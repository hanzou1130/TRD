# TAUJ0ドライバ 詳細設計書

## 1. 概要
本ドキュメントは、TAUJ0ドライバの各関数の内部処理ロジック、変数定義、およびアルゴリズムの詳細を記述する。実装者が本ドキュメントに基づいてコーディング可能なレベルの詳細度とする。

## 2. 定数・マクロ定義

### 2.1 システム定数
| マクロ名 | 値 | 説明 |
|----------|----|------|
| `SYSTEM_CLOCK_HZ` | `80000000UL` | システムクロック周波数 (80MHz) |
| `TAUJ0_PRESCALER` | `1UL` | TAUJ0クロックプリスケーラ (PCLK/1) |

### 2.2 レジスタアドレス
`tauj0_regs.h` で定義される構造体ポインタ `TAUJ0` を使用してアクセスする。
ベースアドレス: `0xFFE50000`

## 3. 関数詳細設計

### 3.1 TAUJ0_Init

#### 3.1.1 処理概要
TAUJ0チャネル0をインターバルタイマモードで初期化する。

#### 3.1.2 引数・戻り値
- **引数**: `uint32_t interval_us` (インターバル周期 [us])
- **戻り値**: なし

#### 3.1.3 内部変数
なし

#### 3.1.4 処理フロー
![TAUJ0_Init フローチャート](flowcharts/tauj0_init.svg)


#### 3.1.5 実装詳細
1.  **タイマ停止**: `TAUJ0.TT0` レジスタのビット0に1を書き込み、カウント動作を確実に停止させる。
2.  **モード設定**: `TAUJ0.CMOR0` レジスタに `0x0000` を書き込む。
    -   `CKS[1:0] = 00`: 動作クロックとしてCK0を選択。
    -   `MD0 = 0`: インターバルタイマモードを選択。
3.  **インターバル設定**: `TAUJ0_SetInterval` 関数を呼び出し、`interval_us` に基づくカウント値を設定する。

---

### 3.2 TAUJ0_Start

#### 3.2.1 処理概要
TAUJ0チャネル0のカウント動作を開始する。

#### 3.2.2 引数・戻り値
- **引数**: なし
- **戻り値**: なし

#### 3.2.3 処理フロー
![TAUJ0_Start フローチャート](flowcharts/tauj0_start.svg)


#### 3.2.4 実装詳細
1.  **スタートトリガ**: `TAUJ0.TS0` レジスタのビット0に1を書き込む。これにより `TE0` (Timer Enable) ビットがセットされ、カウントダウンが開始される。

---

### 3.3 TAUJ0_Stop

#### 3.3.1 処理概要
TAUJ0チャネル0のカウント動作を停止する。

#### 3.3.2 引数・戻り値
- **引数**: なし
- **戻り値**: なし

#### 3.3.3 処理フロー
![TAUJ0_Stop フローチャート](flowcharts/tauj0_stop.svg)


#### 3.3.4 実装詳細
1.  **ストップトリガ**: `TAUJ0.TT0` レジスタのビット0に1を書き込む。これにより `TE0` ビットがクリアされ、カウントが停止する。

---

### 3.4 TAUJ0_SetInterval

#### 3.4.1 処理概要
指定されたマイクロ秒単位の時間からタイマカウント値を計算し、レジスタに設定する。

#### 3.4.2 引数・戻り値
- **引数**: `uint32_t interval_us` (インターバル周期 [us])
- **戻り値**: なし

#### 3.4.3 内部変数
- `uint32_t counts`: 計算されたレジスタ設定値

#### 3.4.4 処理フロー
![TAUJ0_SetInterval フローチャート](flowcharts/tauj0_setinterval.svg)


#### 3.4.5 実装詳細
1.  **カウント値計算**:
    -   オーバーフローを防ぐため、および64ビット除算を回避するため、以下の簡略化された計算式を使用する。
    -   `counts = interval_us * (SYSTEM_CLOCK_HZ / 1000000UL)`
    -   `SYSTEM_CLOCK_HZ` が80MHzの場合、1usあたり80カウントとなる。
2.  **レジスタ設定**: 計算結果を `TAUJ0.CDR0` レジスタに書き込む。
    -   注意: タイマ動作中に書き込んだ場合、次回のアンダーフロー後に新しい値がリロードされる。

## 4. エラーハンドリング
本ドライバは軽量化のため、引数チェック（NULLポインタチェックや範囲チェック）を行わない。アプリケーション側で適切な値を保証すること。
特に `interval_us` が大きすぎて32ビットカウンタ値を超過する場合 (`interval_us > 53,687,091`) の動作は保証しない（オーバーフローして誤った周期になる）。
